#include <stdio.h>
#define TAILLE_TABLEAU 5


/* déclaration d'un tableau d'entiers global : c'est lui qui sera rempli et trié */
/* NE PAS MODIFIER */
int tab[TAILLE_TABLEAU];

/* déclarations des fonctions utilisées */
/* NE PAS MODIFIER */
void triTableau();
void afficheTableau();
void qksort(int indiceInferieur, int indiceSuperieur);
int lireEntier();



/* programme principal */
/* LA FONCTION main() CONTIENT DES ERREURS QUI SONT A CORRIGER */

int main() {
	float reponse=1; /* réponse de l'utilisateur */   /*  accent + non affecté */
	/* int tab[TAILLE_TABLEAU];  tableau à trier */
	int indice;    /*  non déclaré  */

	/* tant que la réponse (à la question "voulez-vous quitter?") n'est pas oui
	   lire les valeurs du tableau, l'afficher, le trier et l'afficher à nouveau */
	while (reponse == 1) {   /*  accent  +  test au lieu de affectation  */

		/* saisie des entiers du tableau */
		printf("Donnez les valeurs des entiers à trier\n");
		for (indice = 0 ;  indice < TAILLE_TABLEAU ; indice++ )    /*  erreur sens progression  */
		{     /*  erreur crochet  */
		    printf("Veuillez saisir la valeur numéro %d : \n", indice);
			tab[indice] = lireEntier();     /*  erreur i + erreur ;   +  erreur param   */
		}

		/* vérification de la saisie */
		printf("Contenu du tableau non trié : \n");
		afficheTableau();

		/* tri du tableau par l'algorithme du QuickSort */
		triTableau();

		/* affichage du tableau après tri */
		printf("Contenu du tableau trié : \n");
		afficheTableau();

		/* propose à l'utilisateur de faire un autre tri */
		printf("Recommencer avec un nouveau tableau ? ('1' pour oui, autre entier sinon)\n");
		reponse = lireEntier();     /*  aucune affectation --> bouclage infini  +  no param */
	}

	return("le programme est terminé");
}


/* fonction d'affichage du contenu du tableau */
/* LA FONCTION afficheTableau() CONTIENT DES ERREURS QUI SONT A CORRIGER */


void afficheTableau() {
	int indice;
	for (indice = 0; indice < TAILLE_TABLEAU; indice++) {
		printf("[%d]\t", tab[indice]);
	}
    	printf("\n");
}




/* fonction réalisant un tri du tableau global tab par l'algorithme du QuickSort */
/* CETTE FONCTION NE CONTIENT PAS D'ERREURS A CORRIGER MAIS VOUS DEVEZ L'INDENTER PROPREMENT */


void qksort(int ind_inf, int ind_sup) {
    int pivot;                /* valeur pivot pour partionner le tableau */
    int borne_inf, borne_sup; /* indices marquant la fin des regions non partitionnées */
    int ind_egal;             /* plus petit indice du tableau dont l'élément a une valeur égale au pivot */
    int temp;	          /* variable temporaire, pour les échanges */

    /* on sort de la fonction si les bornes ne sont pas valides */
    if ((ind_inf >= ind_sup) || (ind_inf < 0) || (ind_sup > TAILLE_TABLEAU - 1)) {
        return;
    }
    /* choix d'une valeur pivot */
    pivot = tab[(ind_inf + ind_sup)/2];
    /* initialisations */
    ind_egal = borne_inf = ind_inf;
    borne_sup = ind_sup;

    /* tant que la partie non triée n'est pas vide, on réduit sa taille */
    while (borne_inf <= borne_sup) {
        if (tab[borne_sup] > pivot)
        {
            /* ici, on peut diminuer la taille de la partie non partitionnée et réessayer */
            borne_sup = borne_sup - 1;
        }
        else {
            /* ici, tab[borne_sup] <= pivot, on échange les nombres en borne_inf et borne_sup */
            temp = tab[borne_inf];
            tab[borne_inf] = tab[borne_sup];
            tab[borne_sup] = temp;

            /* après l'échange, tab[borne_inf] <= pivot.*/
            if (tab[borne_inf] < pivot) {
                /* on échange les nombres entre ind_egal et borne_inf */
                temp = tab[ind_egal];
                tab[ind_egal] = tab[borne_inf];
                tab[borne_inf] = temp;
                /* après l'échange, tab[ind_egal] < pivot, il faut changer ind_egal */
                ind_egal = ind_egal + 1;
                /* il faut aussi changer borne_inf, mais il faut aussi le faire */
                /* quand tab[borne_inf] = pivot, donc on le fait après le if */
            }
            /* on peut encore réduire la taille de la partie non partitionnée et réessayer */
            borne_inf = borne_inf + 1;
        }
    }
    /* Maintenant, toutes les entrées du tableau de l'indice ind_inf à ind_egal - 1 sont < pivot
        et toutes les entrées entre borne_sup et ind_sup + 1 sont > pivot
        Nous avons donc deux parties de tableau pouvant être triées récursivement */
    qksort(ind_inf, ind_egal - 1);
    qksort(borne_sup + 1, ind_sup);
}






/* --------------------------------------------------------------


   NE PAS MODIFIER LES LIGNES DU PROGRAMME A PARTIR D'ICI


 -------------------------------------------------------------- */




/*
  Retourne un entier lu au clavier avec vérification de la validité du format
  (si plusieurs entiers sont lus, seul le premier est retourné)
*/

/* NE PAS MODIFIER CETTE FONCTION: NE CONTIENT PAS D'ERREURS */

int lireEntier() {

  int entierLu;
  int nbEntiersLus;
  char videTampon;

  do {
    nbEntiersLus = scanf("%d", &entierLu);
    if (nbEntiersLus != 1) {
      printf("Erreur de format: veuillez saisir un entier.\n");

    }
    /* vidage du reste du tampon (si plusieurs entiers ou saisie invalide) */
    do {
      scanf("%c", &videTampon);
      printf("Dans tampon: %c\n", videTampon);
    } while (videTampon != '\n');
  } while (nbEntiersLus != 1);

  return entierLu;
}


/* fonction de tri de tableau par l'algorithme du QuickSort */

/* NE PAS MODIFIER CETTE FONCTION */

void triTableau() {
    qksort(0, TAILLE_TABLEAU - 1);
}
